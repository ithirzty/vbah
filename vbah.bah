#include "iostream.bah"
#include "time.bah"
#include "<GL/gl.h>"
#include "<GL/glut.h>"

#cLib "lGL" "lglut" "lGLU"

#define! GLuint uint


#define! cos(f float) float
#define! sin(f float) float
#define! sqrt(f float) float

#define! glClearColor(r float, g float, b float, a float)
#define! glClear(b ptr)
#define! glBegin(c ptr)
#define! glColor3f(r float, g float, b float)
#define! glVertex2f( x float, y float )
#define! glEnd()
#define! glutSwapBuffers()

#define! glutInit(argc int*, char**)
#define! glutInitDisplayMode(dm ptr)
#define! glutInitWindowSize(w int,h int)
#define! glutInitWindowPosition(x int,y int)
#define! glutCreateWindow(t cpstring)
#define! glutDisplayFunc(f function())
#define! glutIdleFunc(f function())
#define! glutPostRedisplay()
#define! glutMainLoop()
#define! glColor3f(r float, g float, b float) 
#define! glRasterPos2f(x float, y float)
#define! glutBitmapString(font ptr, str cpstring)
#define! glEnable(m ptr)
#define! glDisable(m ptr)
#define! glGenTextures(i int, t GLuint*)
#define! glBindTexture(tm ptr, t GLuint)
#define! glTexEnvf(tenv ptr, tm ptr, mod ptr)
#define! glTexParameterf(tm ptr, mn ptr, mv ptr)
#define! gluBuild2DMipmaps(tm ptr, nb int, w int, h int, colors ptr, cont ptr, data cpstring)
#define! glTexCoord2f(x float, y float)
#define! glutMouseFunc(f ptr)
#define! glutMotionFunc(f ptr)
#define! glutPassiveMotionFunc(f ptr)
#define! glutKeyboardFunc(f ptr)
#define! glutFullScreen()
#define! glutGet(m ptr) int
#define! gluOrtho2D(l float, r float, b float, t float)
#define! glViewport(l int, t int, r int, b int)
#define! glMatrixMode(m ptr)
#define! glLoadIdentity()
#define! glutReshapeFunc(f ptr)
#define! gluUnProject(wx float, wy float, wz float, m ptr, p ptr, v ptr, x float*, y float*, z float*)
#define! glGetDoublev(w ptr, t float*)
#define! glGetIntegerv(w ptr, t int*)
#define! glPushMatrix()
#define! glPopMatrix()
#define! glTranslated(x float, y float, z float)
#define! glRotated(deg float, x float, y float, z float)
#define! glutReshapeWindow(w int, h int)

const MOUSE_LEFT_BUTTON = 0
const MOUSE_WHEEL_BUTTON = 1
const MOUSE_RIGHT_BUTTON = 2


//Used for getting the lower-left bounding box coordinate of a shape.
minCoords(x float*, y float*, shape []float) {
    if len(shape) < 2 {
        return
    }
    *x = shape[0]
    *y = shape[1]
    i=2; for i < len(shape) {
        if shape[i] < *x {
            *x = shape[i]
        }
        if shape[i+1] < *y {
            *y = shape[i+1]
        }
        i = i + 2
    }
}

//Used for getting the upper-right bounding box coordinate of a shape.
maxCoords(x float*, y float*, shape []float) {
    if len(shape) < 2 {
        return
    }
    *x = shape[0]
    *y = shape[1]
    i=2; for i < len(shape) {
        if shape[i] > *x {
            *x = shape[i]
        }
        if shape[i+1] > *y {
            *y = shape[i+1]
        }
        i = i + 2
    }
}

dot(x1 float, y1 float, x2 float, y2 float) float {
    return x1 * x2 + y1 * x2
}

// Used for translating a shape by x and y.
translateShape(x float, y float, shape []float) {
    i=0; for i < len(shape) {
        shape[i] = shape[i] + x
        shape[i+1] = shape[i+1] + y
        i = i + 2
    }
}

#define centerCoords(x float*, y float*, shape []float)

//Used for generating a circle from a shape.
circleFromShape(x float*, y float*, rad float*, shape []float) {
    centerCoords(x, y, shape)
    minX float
    minY float
    minCoords(&minX, &minY, shape)
    maxX float
    maxY float
    maxCoords(&maxX, &maxY, shape)
    radX = *x - minX
    radY = *y - minY
    minRad = radX + radY / 2.0
    radX = maxX - *x
    radY = maxY - *y
    maxRad = radX + radY / 2.0
    if minRad > maxRad {
        *rad = minRad
    } else {
        *rad = maxRad
    }
}

degToRad(d float) float {
    return d * 3.14159 / 180.0
}

//Used for rotating a shape.
//Rotation in degrees.
rotateShape(rot float, shape []float) {
    rot = degToRad(rot)
    mat = []float
    nx = []float
    ny = []float

    allocateArray(mat, 4)
    allocateArray(nx, 2)
    allocateArray(ny, 2)

    mat[0] = cos(rot)
    mat[1] = -1.0 * sin(rot)
    mat[2] = sin(rot)
    mat[3] = cos(rot)

    i=0; for i < len(shape) {
        sx = shape[i]
        sy = shape[i+1]

        nx[0] = sx * mat[0]
        nx[1] = sx * mat[1]

        ny[0] = sy * mat[2]
        ny[1] = sy * mat[3]

        shape[i] = ny[0] + nx[0]
        shape[i+1] = ny[1] + nx[1]

        i = i + 2
    }
}

//Used for detecting if two circle are colliding.
detectCollideCircle(x1 float, y1 float, rad1 float, x2 float, y2 float, rad2 float) bool {
    distX = x1 - x2
    distY = y1 - y2
    sumRad = rad1 + rad2
    if distX * distX + distY * distY <= sumRad * sumRad {
        return true
    }
    return false
}

//Used for opennning a BMP file and transforming it into a texture.
BMPtoTex(path cpstring, w int, h int) GLuint {
    texture GLuint
    fs = fileStream{}
    fs.open(path, "rb")
    fs.setPos(54)
    if fs.isValid() == 0 {
        return null
    }
    //read file
    data = fs.readBytes()
    fs.close()
    //converting BMP bgr to rgb
    i=0; for i < w * h {
        index = i * 3
        b = data[index]
        r = data[index+2]
        data[index] = r
        data[index+2] = b
        i = i + 1
    }

    glGenTextures(1, &texture)
    glBindTexture(noCheck(GL_TEXTURE_2D), texture)
    glTexEnvf(noCheck(GL_TEXTURE_ENV), noCheck(GL_TEXTURE_ENV_MODE), noCheck(GL_MODULATE))
    glTexParameterf(noCheck(GL_TEXTURE_2D), noCheck(GL_TEXTURE_MIN_FILTER), noCheck(GL_LINEAR_MIPMAP_NEAREST))
    glTexParameterf(noCheck(GL_TEXTURE_2D), noCheck(GL_TEXTURE_MAG_FILTER), noCheck(GL_LINEAR))
    glTexParameterf(noCheck(GL_TEXTURE_2D), noCheck(GL_TEXTURE_WRAP_S), noCheck(GL_REPEAT))
    glTexParameterf(noCheck(GL_TEXTURE_2D), noCheck(GL_TEXTURE_WRAP_T), noCheck(GL_REPEAT))
    gluBuild2DMipmaps(noCheck(GL_TEXTURE_2D), 3, w, h, noCheck(GL_RGB), noCheck(GL_UNSIGNED_BYTE), arrAsStr(data))
    return texture
}


//Used for describing a RGB color value.
//This can also hold a texture.
struct rgb {
    r: float
    g: float
    b: float

    isTex: bool = false
    tex: GLuint
    texW: int
    texH: int
}

//Used for making a rgb structure with the r, g and b values.
rgb(r float, g float, b float) rgb {
    rgb = rgb{}
    rgb.r = r
    rgb.g = g
    rgb.b = b
    return rgb
}

//Used for making a rgb structure with a structure.
rgbTexture(path cpstring, w int, h int) rgb {
    c = rgb{}
    c.isTex = true
    c.tex = BMPtoTex(path, w, h)
    c.texW = w
    c.texH = h
    return c
}

//Used for setting the drawing color/texture.
setDrawingColor(color rgb) bool {
    if color.isTex == false {
        glColor3f(color.r, color.g, color.b)
    } else {
        glColor3f(1.0, 1.0, 1.0)
        glBindTexture(noCheck(GL_TEXTURE_2D), color.tex)
        glEnable(noCheck(GL_TEXTURE_2D))
    }
    return color.isTex
}

//Used for drawing a filled-circle.
drawCircle(x float, y float, radius float, color rgb) {
    setDrawingColor(color)
    glBegin(noCheck(GL_TRIANGLE_FAN))
    texX = 0.5
    texY = 0.5
    glTexCoord2f(texX, texY); glVertex2f(x, y)


    twicePi = 2.0 * 3.142
    res int = radius * 30.0
    if res < 20 {
        res = 20
    }
    i=0; for i <= res {
        xr = radius * cos(<float>i * twicePi / <float>res)
        yr = radius * sin(<float>i * twicePi / <float>res)
        glTexCoord2f(texX + xr, texY + yr); glVertex2f(x + xr, y + yr)
        i = i + 1
    }
    glEnd()
    glDisable(noCheck(GL_TEXTURE_2D))
}

//Used for drawing a box.
drawBox(x float, y float, w float, h float, color rgb) {
    isTex = setDrawingColor(color)
    glBegin(noCheck(GL_TRIANGLE_FAN))
    hw = w / 2.0
    hh = h / 2.0
    glTexCoord2f(0.0,1.0); glVertex2f(x-hw, y+hh)
    glTexCoord2f(1.0,1.0); glVertex2f(x+hw, y+hh)
    glTexCoord2f(1.0,0.0); glVertex2f(x+hw, y-hh)
    glTexCoord2f(0.0,0.0); glVertex2f(x-hw, y-hh)
    glEnd()
    glDisable(noCheck(GL_TEXTURE_2D))
}

//Used for drawing a custom shape.
drawShape(shape []float, color rgb) {
    if len(shape) == 0 {
        return
    }
    isTex = setDrawingColor(color)
    glBegin(noCheck(GL_TRIANGLE_FAN))
    cX float
    cY float
    centerCoords(&cX, &cY, shape)
    i=0; for i < len(shape) {
        glTexCoord2f(shape[i] - cX + 0.5, shape[i+1] - cY + 0.5); glVertex2f(shape[i], shape[i+1])
        i = i + 2
    }
    glEnd()
    glDisable(noCheck(GL_TEXTURE_2D))
}

//Used for drawing text.
drawText(x float, y float, color rgb, font ptr, str cpstring) {
    glColor3f(color.r, color.g, color.b)
    glRasterPos2f(x, y)
    glutBitmapString(font, str)
}

// Used for getting the center of a shape.
centerCoords(x float*, y float*, shape []float) {
    tmpX float
    tmpY float
    i=0; for i < len(shape) {
        tmpX = tmpX + shape[i]
        tmpY = tmpY + shape[i+1]
        i = i + 2
    }
    div = i / 2
    *x = tmpX / <float>div
    *y = tmpY / <float>div    
}


//Used for clearing the screen each frame.
clearFrame() {
    glClearColor(0.0,0.0,0.0,1.0)
    glClear(noCheck(GL_COLOR_BUFFER_BIT))
}

//Used for asking a new frame.
redrawFrame() {
    glutPostRedisplay()
}

//Used for sending the frame.
sendFrame() {
    glutSwapBuffers()
}

#define __VBAH_display()
#define __VBAH_idle()
#define __VBAH_mouse(btn int, state int, x int, y int)
#define __VBAH_move(x int, y int)
#define __VBAH_drag(x int, y int)
#define __VBAH_keyboard(key char, x int, y int)
#define __VBAH_resize(w int, h int)

//Wrapper for a window.
struct window {
    width: int
    height: int
    x: int
    y: int
    title: cpstring
    autoClear: bool = true
    autoLoop: bool = true

    lb: float = -1.0
    tb: float = 1.0
    rb: float = 1.0
    bb: float = -1.0

    display: function()
    idle: function()
    init: function()
    click: function(int, bool, int, int)
    move: function(int, int)
    drag: function(int, int)
    keyboard: function(char, int, int)

    delta: float
    lastTimeDelta: float

    //Used for launching the window.
    launch() {
        glutInitWindowSize(this.width, this.height)
        glutInitWindowPosition(this.x, this.y)
        glutCreateWindow(this.title)
        glutDisplayFunc(__VBAH_display)
        glutIdleFunc(__VBAH_idle)
        glutMouseFunc(__VBAH_mouse)
        glutPassiveMotionFunc(__VBAH_move)
        glutMotionFunc(__VBAH_drag)
        glutKeyboardFunc(__VBAH_keyboard)
        glutReshapeFunc(__VBAH_resize)
        init = this.init
        if init != null {
            init()
        }
        this.lastTimeDelta = <float>getTimeUnix()
        glutMainLoop()
    }

    //Used for starting the delta calculation.
    //Needs to be called at each end of frame.
    endDelta() {
        nltd float = getTimeUnix()
        delta = nltd - this.lastTimeDelta
        this.lastTimeDelta = nltd
        delta = delta / 1000000000.0
        this.delta = delta
        // tmpD = <float>getTimeUnix() - this.tmpDelta
        // this.delta = tmpD / 1000000000.0
    }

    //Used for getting the current number of frame per second.
    fps() int {
        fps = 1.0 / this.delta
        return <int>fps
    }

    oldW: int
    oldH: int
    fullscreened: bool = false

    //Used for making the window full screen.
    fullscreen() {
        if this.fullscreened == false {
            this.oldW = this.width
            this.oldH = this.height
            glutFullScreen()
            this.fullscreened = true
        } else {
            glutReshapeWindow(this.oldW, this.oldH)
            this.fullscreened = false
        }
    }

    //Used for getting window's width.
    getWidth() float {
        return <float>glutGet(noCheck(GLUT_WINDOW_WIDTH))
    }

    //Used for getting window's height.
    getHeight() float {
        return <float>glutGet(noCheck(GLUT_WINDOW_HEIGHT))
    }
}



WINDOW_PTR window*

__VBAH_display() {
    if WINDOW_PTR.autoClear == true {
        clearFrame()
    }
    dsp function() = WINDOW_PTR.display
    if dsp != null {
        dsp()
        sendFrame()
    }
    WINDOW_PTR.endDelta()
}

__VBAH_idle() {
    idl function() = WINDOW_PTR.display
    if idl != null {
        idl()
    }
    if WINDOW_PTR.autoLoop == true {
        redrawFrame()
    }
}

__VBAH_mouse(btn int, state int, x int, y int) {
    mse = WINDOW_PTR.click
    if mse != null {
        clicked = false
        if state == 0 {
            clicked = true
        }
        mse(btn, clicked, x, y)
    }
}

__VBAH_move(x int, y int) {
    mve = WINDOW_PTR.move
    if mve != null {
        mve(x, y)
    }
}

__VBAH_drag(x int, y int) {
    mve = WINDOW_PTR.drag
    if mve != null {
        mve(x, y)
    }
}

__VBAH_keyboard(key char, x int, y int) {
    kb = WINDOW_PTR.keyboard
    if kb != null {
        kb(key, x, y)
    }
}

#define pixelsToCoords(x float*, y float*)

__VBAH_resize(w int, h int) {
    ar = <float>h/<float>w
    WINDOW_PTR.width = w
    WINDOW_PTR.height = h
    glViewport(0,0,w,h)
    glMatrixMode(noCheck(GL_PROJECTION))
    glLoadIdentity()
    if w >= h {
        gluOrtho2D(-1.0/ar, 1.0/ar, -1.0, 1.0)
        WINDOW_PTR.lb = -1.0 / ar
        WINDOW_PTR.rb = 1.0 / ar
        WINDOW_PTR.tb = 1.0      
        WINDOW_PTR.bb = -1.0      
    } else {
        gluOrtho2D(-1.0, 1.0, -1.0*ar, 1.0*ar)
        WINDOW_PTR.lb = -1.0
        WINDOW_PTR.rb = 1.0
        WINDOW_PTR.bb = -1.0 * ar
        WINDOW_PTR.tb = 1.0 * ar
    }
    glMatrixMode(noCheck(GL_MODELVIEW))
}

//Used for converting position in pixels to window coordinates position.
pixelsToCoords(x float*, y float*) {
    m float* = memoryAlloc(SIZE_OF_FLOAT * 16)
    p float* = memoryAlloc(SIZE_OF_FLOAT * 16)
    v int* = memoryAlloc(SIZE_OF_INT * 4)
    glGetDoublev(noCheck(GL_MODELVIEW_MATRIX), m)
    glGetIntegerv(noCheck(GL_VIEWPORT), v)
    glGetDoublev(noCheck(GL_PROJECTION_MATRIX), p)
    nx float
    ny float
    nz float
    gluUnProject(*x, *y, 0.0, m, p, v, &nx, &ny, &nz)
    *x = nx
    *y = ny * -1.0
}

//Used for making a window.
window(w int, h int, t cpstring) window* {
    win = new window
    win.width = w
    win.height = h
    win.title = t
    win.x = 100
    win.y = 100

    argc = 0
    glutInit(&argc, null)
    glutInitDisplayMode(noCheck(GLUT_DOUBLE | GLUT_RGB))
    WINDOW_PTR = win
    return win
}