#include "iostream.bah"
#include "time.bah"
#include "<GL/gl.h>"
#include "<GL/glut.h>"

#cLib "lGL" "lglut" "lGLU"

#define! GLuint uint


#define! cos(f float) float
#define! sin(f float) float
#define! sqrt(f float) float

#define! glClearColor(r float, g float, b float, a float)
#define! glClear(b ptr)
#define! glBegin(c ptr)
#define! glColor3f(r float, g float, b float)
#define! glVertex2f( x float, y float )
#define! glEnd()
#define! glutSwapBuffers()

#define! glutInit(argc int*, char**)
#define! glutInitDisplayMode(dm ptr)
#define! glutInitWindowSize(w int,h int)
#define! glutInitWindowPosition(x int,y int)
#define! glutCreateWindow(t cpstring)
#define! glutDisplayFunc(f function())
#define! glutIdleFunc(f function())
#define! glutPostRedisplay()
#define! glutMainLoop()
#define! glColor3f(r float, g float, b float) 
#define! glRasterPos2f(x float, y float)
#define! glutBitmapString(font ptr, str cpstring)
#define! glEnable(m ptr)
#define! glDisable(m ptr)
#define! glGenTextures(i int, t GLuint*)
#define! glBindTexture(tm ptr, t GLuint)
#define! glTexEnvf(tenv ptr, tm ptr, mod ptr)
#define! glTexParameterf(tm ptr, mn ptr, mv ptr)
#define! gluBuild2DMipmaps(tm ptr, nb int, w int, h int, colors ptr, cont ptr, data cpstring)
#define! glTexCoord2f(x float, y float)

//Used for opennning a BMP file and transforming it into a texture.
BMPtoTex(path cpstring, w int, h int) GLuint {
    texture GLuint
    fs = fileStream{}
    fs.open(path, "rb")
    fs.setPos(54)
    if fs.isValid() == 0 {
        return null
    }
    //read file
    data = fs.readBytes()
    fs.close()
    //converting BMP bgr to rgb
    i=0; for i < w * h {
        index = i * 3
        b = data[index]
        r = data[index+2]
        data[index] = r
        data[index+2] = b
        i = i + 1
    }

    glGenTextures(1, &texture)
    glBindTexture(noCheck(GL_TEXTURE_2D), texture)
    glTexEnvf(noCheck(GL_TEXTURE_ENV), noCheck(GL_TEXTURE_ENV_MODE), noCheck(GL_MODULATE))
    glTexParameterf(noCheck(GL_TEXTURE_2D), noCheck(GL_TEXTURE_MIN_FILTER), noCheck(GL_LINEAR_MIPMAP_NEAREST))
    glTexParameterf(noCheck(GL_TEXTURE_2D), noCheck(GL_TEXTURE_MAG_FILTER), noCheck(GL_LINEAR))
    glTexParameterf(noCheck(GL_TEXTURE_2D), noCheck(GL_TEXTURE_WRAP_S), noCheck(GL_REPEAT))
    glTexParameterf(noCheck(GL_TEXTURE_2D), noCheck(GL_TEXTURE_WRAP_T), noCheck(GL_REPEAT))
    gluBuild2DMipmaps(noCheck(GL_TEXTURE_2D), 3, w, h, noCheck(GL_RGB), noCheck(GL_UNSIGNED_BYTE), arrAsStr(data))
    return texture
}


//Used for describing a RGB color value.
//This can also hold a texture.
struct rgb {
    r: float
    g: float
    b: float

    isTex: bool = false
    tex: GLuint
    texW: int
    texH: int
}

//Used for making a rgb structure with the r, g and b values.
rgb(r float, g float, b float) rgb {
    rgb = rgb{}
    rgb.r = r
    rgb.g = g
    rgb.b = b
    return rgb
}

//Used for making a rgb structure with a structure.
rgbTexture(path cpstring, w int, h int) rgb {
    c = rgb{}
    c.isTex = true
    c.tex = BMPtoTex(path, w, h)
    c.texW = w
    c.texH = h
    return c
}

//Used for setting the drawing color/texture.
setDrawingColor(color rgb) bool {
    if color.isTex == false {
        glColor3f(color.r, color.g, color.b)
    } else {
        glBindTexture(noCheck(GL_TEXTURE_2D), color.tex)
        glEnable(noCheck(GL_TEXTURE_2D))
    }
    return color.isTex
}

//Used for drawing a filled-circle.
drawCircle(x float, y float, radius float, color rgb) {
    setDrawingColor(color)
    glBegin(noCheck(GL_TRIANGLE_FAN))
    texX = 0.5
    texY = 0.5
    glTexCoord2f(texX, texY); glVertex2f(x, y)


    twicePi = 2.0 * 3.142
    i=0; for i <= 20 {
        xr = radius * cos(<float>i * twicePi / 20.0)
        yr = radius * sin(<float>i * twicePi / 20.0)
        glTexCoord2f(texX + xr, texY + yr); glVertex2f(x + xr, y + yr)
        i = i + 1
    }
    glEnd()
    glDisable(noCheck(GL_TEXTURE_2D))
}

//Used for drawing a box.
drawBox(x float, y float, w float, h float, color rgb) {
    isTex = setDrawingColor(color)
    glBegin(noCheck(GL_TRIANGLE_FAN))
    hw = w / 2.0
    hh = h / 2.0
    glTexCoord2f(0.0,1.0); glVertex2f(x-hw, y+hh)
    glTexCoord2f(1.0,1.0); glVertex2f(x+hw, y+hh)
    glTexCoord2f(1.0,0.0); glVertex2f(x+hw, y-hh)
    glTexCoord2f(0.0,0.0); glVertex2f(x-hw, y-hh)
    glEnd()
    glDisable(noCheck(GL_TEXTURE_2D))
}

//Used for drawing text.
drawText(x float, y float, color rgb, font ptr, str cpstring) {
    glColor3f(color.r, color.g, color.b)
    glRasterPos2f(x, y)
    glutBitmapString(font, str)
}

//Used for clearing the screen each frame.
clearFrame() {
    glClearColor(0.0,0.0,0.0,1.0)
    glClear(noCheck(GL_COLOR_BUFFER_BIT))
}

//Used for asking a new frame.
redrawFrame() {
    glutPostRedisplay()
}

//Used for sending the frame.
sendFrame() {
    glutSwapBuffers()
}

#define __VBAH_display()
#define __VBAH_idle()

//Wrapper for a window.
struct window {
    width: int
    height: int
    x: int
    y: int
    title: cpstring
    autoClear: bool = true
    autoLoop: bool = true

    display: function()
    idle: function()
    init: function()

    //Used for launching the window.
    launch() {
        glutInitWindowSize(this.width, this.height)
        glutInitWindowPosition(this.x, this.y)
        glutCreateWindow(this.title)
        glutDisplayFunc(__VBAH_display)
        glutIdleFunc(__VBAH_idle)
        init = this.init
        init()
        glutMainLoop()
    }

    delta: float
    tmpDelta: float
    //Used for starting the delta calculation.
    //Needs to be called at each beginning of frame.
    //The resulting delta can be accessed as '.delta'.
    //It is the time in second (float) used for making the last frame.
    startDelta() {
        this.tmpDelta = <float>getTimeUnix()     
    }

    //Used for ending the delta calculation.
    //Needs to be called at each end of frame.
    endDelta() {
        this.delta = <float>getTimeUnix() - this.tmpDelta
        this.delta = this.delta / 1000000000.0
    }

    fps() int {
        fps = 1.0 / this.delta
        return <int>fps
    }
}



WINDOW_PTR window*

__VBAH_display() {
    if WINDOW_PTR.autoClear == true {
        clearFrame()
    }
    dsp function() = WINDOW_PTR.display
    if dsp != null {
        WINDOW_PTR.startDelta()
        dsp()
        WINDOW_PTR.endDelta()
        sendFrame()
    }

}

__VBAH_idle() {
    idl function() = WINDOW_PTR.display
    if idl != null {
        idl()
    }
    if WINDOW_PTR.autoLoop == true {
        redrawFrame()
    }
}

//Used for making a window.
window(w int, h int, t cpstring) window* {
    win = new window
    win.width = w
    win.height = h
    win.title = t
    win.x = 100
    win.y = 100

    argc = 0
    glutInit(&argc, null)
    glutInitDisplayMode(noCheck(GLUT_DOUBLE | GLUT_RGB))
    WINDOW_PTR = win
    return win
}