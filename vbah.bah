#include "iostream.bah"
#include "time.bah"
#include "<GL/gl.h>"
#include "<GL/glut.h>"

#cLib "lGL" "lglut" "lGLU"

#define! GLuint uint


#define! cos(f float) float
#define! sin(f float) float
#define! sqrt(f float) float

#define! glClearColor(r float, g float, b float, a float)
#define! glClear(b ptr)
#define! glBegin(c ptr)
#define! glColor3f(r float, g float, b float)
#define! glVertex2f( x float, y float )
#define! glEnd()
#define! glutSwapBuffers()

#define! glutInit(argc int*, char**)
#define! glutInitDisplayMode(dm ptr)
#define! glutInitWindowSize(w int,h int)
#define! glutInitWindowPosition(x int,y int)
#define! glutCreateWindow(t cpstring)
#define! glutDisplayFunc(f function())
#define! glutIdleFunc(f function())
#define! glutPostRedisplay()
#define! glutMainLoop()
#define! glColor3f(r float, g float, b float) 
#define! glRasterPos2f(x float, y float)
#define! glutBitmapString(font ptr, str cpstring)
#define! glEnable(m ptr)
#define! glDisable(m ptr)
#define! glGenTextures(i int, t GLuint*)
#define! glBindTexture(tm ptr, t GLuint)
#define! glTexEnvf(tenv ptr, tm ptr, mod ptr)
#define! glTexParameterf(tm ptr, mn ptr, mv ptr)
#define! gluBuild2DMipmaps(tm ptr, nb int, w int, h int, colors ptr, cont ptr, data cpstring)
#define! glTexCoord2f(x float, y float)
#define! glutMouseFunc(f ptr)
#define! glutMotionFunc(f ptr)
#define! glutPassiveMotionFunc(f ptr)
#define! glutKeyboardFunc(f ptr)
#define! glutFullScreen()
#define! glutGet(m ptr) int
#define! gluOrtho2D(l float, r float, b float, t float)
#define! glViewport(l int, t int, r int, b int)
#define! glMatrixMode(m ptr)
#define! glLoadIdentity()
#define! glutReshapeFunc(f ptr)
#define! gluUnProject(wx float, wy float, wz float, m ptr, p ptr, v ptr, x float*, y float*, z float*)
#define! glGetDoublev(w ptr, t float*)
#define! glGetIntegerv(w ptr, t int*)

const MOUSE_LEFT_BUTTON = 0
const MOUSE_WHEEL_BUTTON = 1
const MOUSE_RIGHT_BUTTON = 2

//Used for opennning a BMP file and transforming it into a texture.
BMPtoTex(path cpstring, w int, h int) GLuint {
    texture GLuint
    fs = fileStream{}
    fs.open(path, "rb")
    fs.setPos(54)
    if fs.isValid() == 0 {
        return null
    }
    //read file
    data = fs.readBytes()
    fs.close()
    //converting BMP bgr to rgb
    i=0; for i < w * h {
        index = i * 3
        b = data[index]
        r = data[index+2]
        data[index] = r
        data[index+2] = b
        i = i + 1
    }

    glGenTextures(1, &texture)
    glBindTexture(noCheck(GL_TEXTURE_2D), texture)
    glTexEnvf(noCheck(GL_TEXTURE_ENV), noCheck(GL_TEXTURE_ENV_MODE), noCheck(GL_MODULATE))
    glTexParameterf(noCheck(GL_TEXTURE_2D), noCheck(GL_TEXTURE_MIN_FILTER), noCheck(GL_LINEAR_MIPMAP_NEAREST))
    glTexParameterf(noCheck(GL_TEXTURE_2D), noCheck(GL_TEXTURE_MAG_FILTER), noCheck(GL_LINEAR))
    glTexParameterf(noCheck(GL_TEXTURE_2D), noCheck(GL_TEXTURE_WRAP_S), noCheck(GL_REPEAT))
    glTexParameterf(noCheck(GL_TEXTURE_2D), noCheck(GL_TEXTURE_WRAP_T), noCheck(GL_REPEAT))
    gluBuild2DMipmaps(noCheck(GL_TEXTURE_2D), 3, w, h, noCheck(GL_RGB), noCheck(GL_UNSIGNED_BYTE), arrAsStr(data))
    return texture
}


//Used for describing a RGB color value.
//This can also hold a texture.
struct rgb {
    r: float
    g: float
    b: float

    isTex: bool = false
    tex: GLuint
    texW: int
    texH: int
}

//Used for making a rgb structure with the r, g and b values.
rgb(r float, g float, b float) rgb {
    rgb = rgb{}
    rgb.r = r
    rgb.g = g
    rgb.b = b
    return rgb
}

//Used for making a rgb structure with a structure.
rgbTexture(path cpstring, w int, h int) rgb {
    c = rgb{}
    c.isTex = true
    c.tex = BMPtoTex(path, w, h)
    c.texW = w
    c.texH = h
    return c
}

//Used for setting the drawing color/texture.
setDrawingColor(color rgb) bool {
    if color.isTex == false {
        glColor3f(color.r, color.g, color.b)
    } else {
        glBindTexture(noCheck(GL_TEXTURE_2D), color.tex)
        glEnable(noCheck(GL_TEXTURE_2D))
    }
    return color.isTex
}

//Used for drawing a filled-circle.
drawCircle(x float, y float, radius float, color rgb) {
    setDrawingColor(color)
    glBegin(noCheck(GL_TRIANGLE_FAN))
    texX = 0.5
    texY = 0.5
    glTexCoord2f(texX, texY); glVertex2f(x, y)


    twicePi = 2.0 * 3.142
    i=0; for i <= 20 {
        xr = radius * cos(<float>i * twicePi / 20.0)
        yr = radius * sin(<float>i * twicePi / 20.0)
        glTexCoord2f(texX + xr, texY + yr); glVertex2f(x + xr, y + yr)
        i = i + 1
    }
    glEnd()
    glDisable(noCheck(GL_TEXTURE_2D))
}

//Used for drawing a box.
drawBox(x float, y float, w float, h float, color rgb) {
    isTex = setDrawingColor(color)
    glBegin(noCheck(GL_TRIANGLE_FAN))
    hw = w / 2.0
    hh = h / 2.0
    glTexCoord2f(0.0,1.0); glVertex2f(x-hw, y+hh)
    glTexCoord2f(1.0,1.0); glVertex2f(x+hw, y+hh)
    glTexCoord2f(1.0,0.0); glVertex2f(x+hw, y-hh)
    glTexCoord2f(0.0,0.0); glVertex2f(x-hw, y-hh)
    glEnd()
    glDisable(noCheck(GL_TEXTURE_2D))
}

//Used for drawing text.
drawText(x float, y float, color rgb, font ptr, str cpstring) {
    glColor3f(color.r, color.g, color.b)
    glRasterPos2f(x, y)
    glutBitmapString(font, str)
}

//Used for clearing the screen each frame.
clearFrame() {
    glClearColor(0.0,0.0,0.0,1.0)
    glClear(noCheck(GL_COLOR_BUFFER_BIT))
}

//Used for asking a new frame.
redrawFrame() {
    glutPostRedisplay()
}

//Used for sending the frame.
sendFrame() {
    glutSwapBuffers()
}

#define __VBAH_display()
#define __VBAH_idle()
#define __VBAH_mouse(btn int, state int, x int, y int)
#define __VBAH_move(x int, y int)
#define __VBAH_drag(x int, y int)
#define __VBAH_keyboard(key char, x int, y int)
#define __VBAH_resize(w int, h int)

//Wrapper for a window.
struct window {
    width: int
    height: int
    x: int
    y: int
    title: cpstring
    autoClear: bool = true
    autoLoop: bool = true

    lb: float = -1.0
    tb: float = 1.0
    rb: float = 1.0
    bb: float = -1.0

    display: function()
    idle: function()
    init: function()
    click: function(int, bool, int, int)
    move: function(int, int)
    drag: function(int, int)
    keyboard: function(char, int, int)

    delta: float
    lastTimeDelta: float

    //Used for launching the window.
    launch() {
        glutInitWindowSize(this.width, this.height)
        glutInitWindowPosition(this.x, this.y)
        glutCreateWindow(this.title)
        glutDisplayFunc(__VBAH_display)
        glutIdleFunc(__VBAH_idle)
        glutMouseFunc(__VBAH_mouse)
        glutPassiveMotionFunc(__VBAH_move)
        glutMotionFunc(__VBAH_drag)
        glutKeyboardFunc(__VBAH_keyboard)
        glutReshapeFunc(__VBAH_resize)
        init = this.init
        if init != null {
            init()
        }
        this.lastTimeDelta = <float>getTimeUnix()
        glutMainLoop()
    }

    //Used for starting the delta calculation.
    //Needs to be called at each beginning of frame.
    //The resulting delta can be accessed as '.delta'.
    //It is the time in second (float) used for making the last frame.
    startDelta() {
        // this.tmpDelta = <float>getTimeUnix()     
    }

    //Used for ending the delta calculation.
    //Needs to be called at each end of frame.
    endDelta() {
        nltd float = getTimeUnix()
        delta = nltd - this.lastTimeDelta
        this.lastTimeDelta = nltd
        delta = delta / 1000000000.0
        this.delta = delta
        // tmpD = <float>getTimeUnix() - this.tmpDelta
        // this.delta = tmpD / 1000000000.0
    }

    //Used for getting the current number of frame per second.
    fps() int {
        fps = 1.0 / this.delta
        return <int>fps
    }

    //Used for making the window full screen.
    fullscreen() {
        glutFullScreen()
    }

    //Used for getting window's width.
    getWidth() float {
        return <float>glutGet(noCheck(GLUT_WINDOW_WIDTH))
    }

    //Used for getting window's height.
    getHeight() float {
        return <float>glutGet(noCheck(GLUT_WINDOW_HEIGHT))
    }
}



WINDOW_PTR window*

__VBAH_display() {
    if WINDOW_PTR.autoClear == true {
        clearFrame()
    }
    dsp function() = WINDOW_PTR.display
    if dsp != null {
        dsp()
        sendFrame()
    }
    WINDOW_PTR.endDelta()
}

__VBAH_idle() {
    idl function() = WINDOW_PTR.display
    if idl != null {
        idl()
    }
    if WINDOW_PTR.autoLoop == true {
        redrawFrame()
    }
}

__VBAH_mouse(btn int, state int, x int, y int) {
    mse = WINDOW_PTR.click
    if mse != null {
        clicked = false
        if state == 0 {
            clicked = true
        }
        mse(btn, clicked, x, y)
    }
}

__VBAH_move(x int, y int) {
    mve = WINDOW_PTR.move
    if mve != null {
        mve(x, y)
    }
}

__VBAH_drag(x int, y int) {
    mve = WINDOW_PTR.drag
    if mve != null {
        mve(x, y)
    }
}

__VBAH_keyboard(key char, x int, y int) {
    kb = WINDOW_PTR.keyboard
    if kb != null {
        kb(key, x, y)
    }
}

#define pixelsToCoords(x float*, y float*)

__VBAH_resize(w int, h int) {
    ar = <float>h/<float>w
    WINDOW_PTR.width = w
    WINDOW_PTR.height = h
    glViewport(0,0,w,h)
    glMatrixMode(noCheck(GL_PROJECTION))
    glLoadIdentity()
    if w >= h {
        gluOrtho2D(-1.0/ar, 1.0/ar, -1.0, 1.0)
        WINDOW_PTR.lb = -1.0 / ar
        WINDOW_PTR.rb = 1.0 / ar
        WINDOW_PTR.tb = 1.0      
        WINDOW_PTR.bb = -1.0      
    } else {
        gluOrtho2D(-1.0, 1.0, -1.0*ar, 1.0*ar)
        WINDOW_PTR.lb = -1.0
        WINDOW_PTR.rb = 1.0
        WINDOW_PTR.bb = -1.0 * ar
        WINDOW_PTR.tb = 1.0 * ar
    }
    glMatrixMode(noCheck(GL_MODELVIEW))
}

//Used for converting position in pixels to window coordinates position.
pixelsToCoords(x float*, y float*) {
    m float* = memoryAlloc(SIZE_OF_FLOAT * 16)
    p float* = memoryAlloc(SIZE_OF_FLOAT * 16)
    v int* = memoryAlloc(SIZE_OF_INT * 4)
    glGetDoublev(noCheck(GL_MODELVIEW_MATRIX), m)
    glGetIntegerv(noCheck(GL_VIEWPORT), v)
    glGetDoublev(noCheck(GL_PROJECTION_MATRIX), p)
    nx float
    ny float
    nz float
    gluUnProject(*x, *y, 0.0, m, p, v, &nx, &ny, &nz)
    *x = nx
    *y = ny * -1.0
}

//Used for making a window.
window(w int, h int, t cpstring) window* {
    win = new window
    win.width = w
    win.height = h
    win.title = t
    win.x = 100
    win.y = 100

    argc = 0
    glutInit(&argc, null)
    glutInitDisplayMode(noCheck(GLUT_DOUBLE | GLUT_RGB))
    WINDOW_PTR = win
    return win
}