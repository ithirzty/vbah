/////////////////////////////////////////////////////////////
//   Particles system demo using OpenGL and GLUT in Bah.   //
//       To compile, use 'bah ./particles.bah -d'.         //
//                                                         //
//                                     © Aloïs Laurent Boë //
/////////////////////////////////////////////////////////////

#include "iostream.bah"
#include "time.bah"
#include "rand.bah"

#include "../vbah.bah"

win window*

//Used for generating a random float between 0.0 and 1.0.
randFloat() float {
    f = <float>randomInRange(0, 100000) / 100000.0
    return f
}


//Representation of a single particle.
struct part {
    x: float = 0.0
    y: float = 0.0
    velX: float = 0.0
    velY: float = 0.0

    radius: float = 0.08

    r: float = 1.0
    g: float = 1.0
    b: float = 1.0

    //Used for colliding the particle with the borders of the window.
    collideBorders() {
        if this.x - this.radius <= -1.0 {
            this.x = -1.0 + this.radius
            this.velX = -1.0 * this.velX
        } else if this.x + this.radius >= 1.0 {
            this.x = 1.0 - this.radius
            this.velX = -1.0 * this.velX
        }
        if this.y - this.radius <= -1.0 {
            this.y = -1.0 + this.radius
            this.velY = -1.0 * this.velY
        } else if this.y + this.radius >= 1.0 {
            this.y = 1.0 - this.radius
            this.velY = -1.0 * this.velY
        }
    }

    //Used for colliding a particle with another.
    collide(p part*) {
        distX = this.x - p.x
        distY = this.y - p.y
        sumRad = this.radius + p.radius

        if distX * distX + distY * distY <= sumRad * sumRad {
            distX2 = distX * distX
            distY2 = distY * distY
            dist = sqrt(distX2 + distY2)
            if dist == 0.0 {
                dist = 1.0
            }
            velX = distX / dist
            velY = distY / dist
            p.velX = p.velX + velX * -1.0
            p.velY = p.velY + velY * -1.0
            this.velX = this.velX + velX// * 0.5
            this.velY = this.velY + velY// * 0.5
            sumRad = sumRad + 0.0001
            this.x = p.x + sumRad * velX
            this.y = p.y + sumRad * velY
        }
    }

    //Used for drawing the particle.
    draw() {
        this.x = this.x + this.velX * win.delta
        this.y = this.y + this.velY * win.delta
        this.collideBorders()
        drawCircle(this.x, this.y, this.radius, rgb(this.r, this.g, this.b))
    }

}

//A wrapper for the whole particle system.
struct ps {
    gravity: float = 15.0
    globalRad: float = 0.02
    nbParts: int = 20
    parts: []part*
    
    //Used for initiating the particle system.
    init() {
        i=0; for i < this.nbParts {
            p = new part
            p.radius = this.globalRad
            p.velX = randFloat() + 0.7
            p.velY = randFloat() + 0.7
            p.r = randFloat()
            p.g = randFloat()
            p.b = randFloat()
            this.parts[i] = p
            i = i + 1
        }
    }

    //Used for adding a particle.
    add(nb int) {
        nb = this.nbParts + nb
        i=this.nbParts
        for i < nb {
            p = new part
            p.radius = this.globalRad
            p.velX = randFloat() + 0.7
            p.velY = randFloat() + 0.7
            p.r = randFloat()
            p.g = randFloat()
            p.b = randFloat()
            this.parts[i] = p
            i = i + 1
        }
        this.nbParts = nb
    }

    //Used for colliding and drawing every particles.
    draw() {
        i=0; for i < this.nbParts {
            p = this.parts[i]
            p.velY = p.velY - this.gravity * win.delta
            j=0; for j < this.nbParts {
                p1 = this.parts[j]
                p.collide(p1)
                j = j + 1
            }
            p.draw()
            i = i + 1
        }
    }

}



particles ps
lastPart int

//Called on each frame.
display() {
    //Adding a particle evry second.
    if particles.nbParts < 200 && getTimeUnix() - lastPart > 1000000000 {
        particles.add(1)
        lastPart = getTimeUnix()
    }
    //Drawing particles.
    particles.draw()
    
    //drawing the fps count at the top left of the window.
    drawText(-1.0, 0.94, rgb(1.0, 1.0, 1.0), noCheck(GLUT_BITMAP_TIMES_ROMAN_24), intToStr(win.fps())+"fps")
}


main(args []cpstring) int {
    //particle system
    particles = ps{}
    particles.globalRad = 0.05
    particles.nbParts = 150
    particles.init()
    lastPart = getTimeUnix()

    //launching the window
    win = window(600, 600, "Particles")
    win.display = display
    win.launch()

    return 0
}