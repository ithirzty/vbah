/////////////////////////////////////////////////////////////
//   Particles system demo using OpenGL and GLUT in Bah.   //
//       To compile, use 'bah ./particles.bah -d'.         //
//                                                         //
//                                     © Aloïs Laurent Boë //
/////////////////////////////////////////////////////////////

#include "iostream.bah"
#include "time.bah"
#include "rand.bah"

#include "../vbah.bah"

win window*

//Used for generating a random float between 0.0 and 1.0.
randFloat() float {
    f = <float>randomInRange(0, 100000) / 100000.0
    return f
}


//Representation of a single particle.
struct part {
    x: float = 0.0
    y: float = 0.0
    velX: float = 0.0
    velY: float = 0.0

    radius: float = 0.08

    r: float = 1.0
    g: float = 1.0
    b: float = 1.0

    //Used for colliding the particle with the borders of the window.
    collideBorders() {
        
        if this.x - this.radius <= win.lb {
            this.x = win.lb + this.radius
            this.velX = -0.9 * this.velX
        } else if this.x + this.radius >= win.rb {
            this.x = win.rb - this.radius
            this.velX = -0.9 * this.velX
        }
        if this.y - this.radius <= win.bb {
            this.y = win.bb + this.radius
            this.velY = -0.9 * this.velY
        } else if this.y + this.radius >= win.tb {
            this.y = win.tb - this.radius
            this.velY = -0.9 * this.velY
        }
    }

    //Used for colliding a particle with another.
    collide(p part*) {
        distX = this.x - p.x
        distY = this.y - p.y
        sumRad = this.radius + p.radius

        if distX * distX + distY * distY <= sumRad * sumRad {
            distX2 = distX * distX
            distY2 = distY * distY
            dist = sqrt(distX2 + distY2)
            if dist == 0.0 {
                dist = 1.0
            }
            velX = distX / dist
            velY = distY / dist
            if p != null {
                p.velX = p.velX + velX * -0.4
                p.velY = p.velY + velY * -0.4
            }
            this.velX = this.velX + velX * 0.4
            this.velY = this.velY + velY * 0.4
            sumRad = sumRad + 0.0001
            this.x = p.x + sumRad * velX
            this.y = p.y + sumRad * velY
        }
    }

    //Used for drawing the particle.
    draw() {
        this.x = this.x + this.velX * win.delta
        this.y = this.y + this.velY * win.delta
        this.collideBorders()
        drawCircle(this.x, this.y, this.radius, rgb(this.r, this.g, this.b))
    }

}

//A wrapper for the whole particle system.
struct ps {
    gravity: float = 5.0
    globalRad: float = 0.02
    nbParts: int = 20
    parts: []part*
    
    //Used for initiating the particle system.
    init() {
        i=0; for i < this.nbParts {
            p = new part
            p.radius = this.globalRad
            p.velX = randFloat() - 0.5
            p.velY = randFloat() - 0.5
            p.r = randFloat()
            p.g = randFloat()
            p.b = randFloat()
            this.parts[i] = p
            i = i + 1
        }
    }

    //Used for adding a particle.
    add(nb int, x float, y float, rad float) {
        i = 0; j = 0
        for i < nb {
            p = new part
            p.radius = this.globalRad
            p.velX = randFloat() - 0.5
            p.velY = randFloat() - 0.5
            p.r = randFloat()
            p.g = randFloat()
            p.b = randFloat()
            p.x = x
            p.radius = rad
            p.y = y
            placed = false
            for j < len(this.parts) {
                op = this.parts[j]
                if op == null {
                    placed = true
                    this.parts[j] = p
                    break
                }
                j = j + 1
            }
            if placed == false {
                this.parts[len(this.parts)] = p
            }
            this.nbParts = this.nbParts + 1
            i = i + 1
        }
    }

    //Used for deleting particles at the specified coordinates.
    remove(x float, y float) {
        i=0; for i < len(this.parts) {
            p = this.parts[i]
            if p == null {
                i = i + 1
                continue
            }
            distX = x - p.x
            distY = y - p.y
            sumRad = p.radius
            if distX * distX + distY * distY <= sumRad * sumRad {
                this.parts[i] = null
                this.nbParts = this.nbParts - 1
            }
            i = i + 1
        }
    }

    //Used for colliding and drawing every particles.
    draw() {
        i=0; for i < len(this.parts) {
            p = this.parts[i]
            if p == null {
                i = i + 1
                continue
            }
            p.velY = p.velY - this.gravity * win.delta
            j=0; for j < len(this.parts) {
                p1 = this.parts[j]
                if p1 == null {
                    j = j + 1
                    continue
                }
                p.collide(p1)
                j = j + 1
            }
            p.draw()
            i = i + 1
        }
    }

}



particles ps
lastPart int

//Called on each frame.
display() {
    //Adding a particle evry second.
    if particles.nbParts < 20 && getTimeUnix() - lastPart > 1000000000 {
        particles.add(1, 0.0, 0.0, 0.055)
        lastPart = getTimeUnix()
    }
    //Drawing particles.
    particles.draw()
    
    //drawing the fps count at the top left of the window.
    //0px from the left
    //24px from the top
    tx = 0.0; ty = 24.0
    pixelsToCoords(&tx, &ty)
    drawText(tx, ty, rgb(1.0, 1.0, 1.0), noCheck(GLUT_BITMAP_TIMES_ROMAN_24), intToStr(win.fps())+" fps\n"+intToStr(particles.nbParts)+" particles")
}

currentBtn int

handleMouse(x int, y int) {
    xf float = x
    yf float = y
    pixelsToCoords(&xf, &yf)
    if currentBtn == MOUSE_LEFT_BUTTON {
        particles.add(1, xf, yf, 0.04)
    } else if currentBtn == MOUSE_RIGHT_BUTTON {
        particles.remove(xf, yf)
    }
}

click(btn int, pressed bool, x int, y int) {
    if pressed == false {
        return
    }
    currentBtn = btn
    handleMouse(x, y)
}

main(args []cpstring) int {
    //particle system
    particles = ps{}
    particles.globalRad = 0.055
    particles.nbParts = 20
    particles.init()
    lastPart = getTimeUnix()

    //launching the window
    win = window(600, 600, "Particles")
    win.display = display
    win.click = click
    win.drag = handleMouse
    win.launch()

    return 0
}